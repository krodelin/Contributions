| package |
package := Package name: 'US Time Extensions'.
package paxVersion: 1;
	basicComment: ''.

package basicPackageVersion: '0.010'.


package methodNames
	add: #Date -> #asDATE;
	add: #Locale -> #bias;
	add: #Time -> #asUTC;
	add: #TimeStamp -> #asDATE;
	add: #TimeStamp -> #asUnixEpocheSeconds;
	add: 'Time class' -> #fromHours:minutes:seconds:milliseconds:;
	add: 'Time class' -> #fromHours:minutes:seconds:millisecondsFraction:;
	add: 'Time class' -> #fromUtcHours:minutes:seconds:milliseconds:;
	add: 'Time class' -> #fromUtcHours:minutes:seconds:millisecondsFraction:;
	add: 'Time class' -> #fromUtcTime:;
	add: 'TimeStamp class' -> #currentUnixEpochSeconds;
	add: 'TimeStamp class' -> #fromUnixEpocheSeconds:;
	add: 'TimeStamp class' -> #unixEpoche;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\..\..\Core\Object Arts\Dolphin\Base\Dolphin';
	yourself).

package!

"Class Definitions"!


"Global Aliases"!


"Loose Methods"!

!Date methodsFor!

asDATE
^self asParameter asFloat! !
!Date categoriesFor: #asDATE!public! !

!Locale methodsFor!

bias
	^(self timeZoneInformation ) bias! !
!Locale categoriesFor: #bias!public! !

!Time methodsFor!

asUTC

	^self addTime: (Time fromSeconds: (Locale userDefault bias) * 60)! !
!Time categoriesFor: #asUTC!public! !

!Time class methodsFor!

fromHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds 
	^Time 
		fromMilliseconds: (((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds) asInteger!

fromHours: hours minutes: minutes seconds: seconds millisecondsFraction: millisecondsFraction 
	^self 
		fromHours: hours
		minutes: minutes
		seconds: seconds
		milliseconds: (millisecondsFraction notNull 
				ifTrue: [millisecondsFraction / (10 raisedTo: millisecondsFraction log ceiling)]
				ifFalse: [0]) * 1000!

fromUtcHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds 
	^Time fromUtcTime: (Time 
				fromMilliseconds: (((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds )asInteger)!

fromUtcHours: hours minutes: minutes seconds: seconds millisecondsFraction: millisecondsFraction 
	^self 
		fromUtcHours: hours
		minutes: minutes
		seconds: seconds
		milliseconds: (millisecondsFraction notNull 
				ifTrue: [millisecondsFraction / (10 raisedTo: millisecondsFraction log ceiling)]
				ifFalse: [0]) * 1000!

fromUtcTime: aTime 
	^aTime subtractTime: (Time fromSeconds: Locale userDefault bias * 60)! !
!Time class categoriesFor: #fromHours:minutes:seconds:milliseconds:!public! !
!Time class categoriesFor: #fromHours:minutes:seconds:millisecondsFraction:!public! !
!Time class categoriesFor: #fromUtcHours:minutes:seconds:milliseconds:!public! !
!Time class categoriesFor: #fromUtcHours:minutes:seconds:millisecondsFraction:!public! !
!Time class categoriesFor: #fromUtcTime:!public! !

!TimeStamp methodsFor!

asDATE
^self asParameter asFloat!

asUnixEpocheSeconds
^self asSeconds - self class unixEpoche asSeconds.! !
!TimeStamp categoriesFor: #asDATE!public! !
!TimeStamp categoriesFor: #asUnixEpocheSeconds!public! !

!TimeStamp class methodsFor!

currentUnixEpochSeconds
	^self currentUTC asUnixEpocheSeconds!

fromUnixEpocheSeconds: seconds 
	^self fromSeconds: self unixEpoche asSeconds + seconds!

unixEpoche
	^##(self date: (Date 
				newDay: 1
				monthIndex: 1
				year: 1970)
		time: (Time 
				hours: 0
				minutes: 0
				seconds: 0))! !
!TimeStamp class categoriesFor: #currentUnixEpochSeconds!public! !
!TimeStamp class categoriesFor: #fromUnixEpocheSeconds:!public! !
!TimeStamp class categoriesFor: #unixEpoche!public! !

"End of package definition"!

