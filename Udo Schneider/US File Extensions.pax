| package |
package := Package name: 'US File Extensions'.
package paxVersion: 1;
	basicComment: ''.

package basicPackageVersion: '0.012'.


package methodNames
	add: #Character -> #isInvalidInFilename;
	add: #Character -> #isValidInFilename;
	add: #FileLocator -> #isRelativePath:;
	add: #KernelLibrary -> #createHardLink:lpExistingFileName:;
	add: #KernelLibrary -> #createHardLink:lpExistingFileName:lpSecurityAttributes:;
	add: #KernelLibrary -> #getLongPathName:lpszLongPath:cchBuffer:;
	add: 'Character class' -> #invalidPathChars;
	add: 'File class' -> #hardLink:to:;
	add: 'File class' -> #longPathOf:;
	add: 'File class' -> #sizeOf:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\..\Core\Object Arts\Dolphin\Base\Dolphin';
	yourself).

package!

"Class Definitions"!


"Global Aliases"!


"Loose Methods"!

!Character methodsFor!

isInvalidInFilename
	^(self class invalidPathChars includes: self) !

isValidInFilename
	^self isInvalidInFilename not! !
!Character categoriesFor: #isInvalidInFilename!public!testing! !
!Character categoriesFor: #isValidInFilename!public!testing! !

!Character class methodsFor!

invalidPathChars
^##((((0 to: 31) collect: [:each | Character value: each]) , '\/:*?"<>|') asSortedCollection)! !
!Character class categoriesFor: #invalidPathChars!constants!public! !

!File class methodsFor!

hardLink: destination to: source
^KernelLibrary default createHardLink: destination lpExistingFileName: source!

longPathOf: aPathnameString 
	"Answers the long path version of aPathnameString"

	| longpath |
	longpath := String new: self maxPath.
	(KernelLibrary default 
		getLongPathName: aPathnameString
		lpszLongPath: longpath
		cchBuffer: longpath size) == 0 
		ifTrue: [KernelLibrary default systemError].
	^longpath trimNulls!

sizeOf: aFilename 
	| file size |
	[file := self open: aFilename.
	size := file size.
	] ensure: [file close].
	^size! !
!File class categoriesFor: #hardLink:to:!public! !
!File class categoriesFor: #longPathOf:!filename manipulation!public! !
!File class categoriesFor: #sizeOf:!public! !

!FileLocator methodsFor!

isRelativePath: aPath 
	^File isRelativePath: (self relativePathTo: aPath)! !
!FileLocator categoriesFor: #isRelativePath:!public! !

!KernelLibrary methodsFor!

createHardLink: lpFileName lpExistingFileName: lpExistingFileName 
	| return |
	return := self 
				createHardLink: lpFileName
				lpExistingFileName: lpExistingFileName
				lpSecurityAttributes: nil.
	return = false ifTrue: [self systemError: self getLastError].
	^return!

createHardLink: lpFileName lpExistingFileName: lpExistingFileName lpSecurityAttributes: lpSecurityAttributes 
	"Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories
	BOOL WINAPI CreateHardLink(
		__in        LPCTSTR lpFileName,
		__in        LPCTSTR lpExistingFileName,
		__reserved  LPSECURITY_ATTRIBUTES lpSecurityAttributes
	);"

	<stdcall: bool CreateHardLinkA char* char* lpvoid>
	^self invalidCall!

getLongPathName: lpszShortPath lpszLongPath: lpszLongPath cchBuffer: cchBuffer 
	"Answers the long pathname form of lpszShortPath in lpszLongPath"

	<stdcall: dword GetLongPathNameA lpstr lpstr dword>
	^self invalidCall! !
!KernelLibrary categoriesFor: #createHardLink:lpExistingFileName:!public!win32 functions-file! !
!KernelLibrary categoriesFor: #createHardLink:lpExistingFileName:lpSecurityAttributes:!public!win32 functions-file! !
!KernelLibrary categoriesFor: #getLongPathName:lpszLongPath:cchBuffer:!public!win32 functions-file! !

"End of package definition"!

